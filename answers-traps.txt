Q1 哪些寄存器用于传参？在 main 调用 printf 时，常数 13 放在哪个寄存器？
RISC-V 采用 a0–a7 作为前 8 个整型/指针实参寄存器；更多参数经栈传递。在 call.asm 里可见把 13 装入某个 a*，例如类似 li a2,13 这样的序列，因此 13 位于 a2。格式字符串位于 a0，另外一个整型参数位于 a1。这一点在原文档的答案提示里也给出了相同结论。

Q2 调用 printf 时，哪条指令保存返回地址？
典型调用形态是 jal ra, printf：jal 指令会把下一条指令地址写入 ra（x1），从而函数返回时 ret（实为 jalr x0, 0(ra)）可以跳回；若函数内需要跨越调用保存 ra，会在函数序言把 ra 用 sd 存到当前栈帧。此过程可在 call.asm 的 main 与 f/g 的序言/尾声中看到。

Q3 返回值存放在什么寄存器？f(8)+1 的返回路径如何？
整数返回值放在 a0。g 把计算结果写入 a0 返回给 f，f 在取回的 a0 上做加法（如 addi a0,a0,1 或先存后取），最终 main 再把该结果作为 printf 的第二个参数放入 a1。这一数据流在 call.asm 中非常直观：g → a0 → f 调整 → a0 → main 放入 a1。

Q4 栈帧是如何建立/释放的？
函数进入时通常见到：
addi sp, sp, -N 预留栈空间；
sd ra, offset(sp) / sd s0, offset(sp) 保存返回地址与帧指针；
addi s0, sp, N 设定帧指针。
返回前相反操作恢复寄存器并 addi sp, sp, N。这些“序言/尾声”模板在 g/f/main 都能看到。

Q5 小端/大端对输出的影响
在把 32/64 位整型按字节解释为字符时，小端机器会把低地址存最低有效字节，所以示例程序会打印出特定字符串（如 “HE110 World” 这一类效果字样，取决于常量与装配方式）。若改为大端，要改变的是装入常量时的字节序（即把原先分布在低地址的字符换到高位），常数本身作为“整体数值”不需要因为端序改变而数值不同。文档中也给了小端/大端讨论的提示。

Q6 printf("x=%d y=%d", 3); 会在 y= 后输出什么？为什么？
不会有确定值：格式串声明需要两个整型实参，但只提供了一个。printf 会继续从调用点约定的位置（寄存器或栈）“读取”第二个实参，于是打印出未定义的垃圾值。这是“参数与格式不匹配”的未定义行为示例，原文档也明确了这一点。