为何调度时不将原有线程的状态改为 RUNNABLE

这里一个常见的错误是在调度时很自然地将原有线程的状态改为 RUNNABLE 。事实上，由于本实验中的线程是主动让出的非抢占式调度，在线程主动让出 CPU 时调用的thread_yield() 中已经进行了状态的改变，故而此处无需对原线程状态进行修改。若在 thread_schedule() 中执行 t->state = RUNNABLE ，则会导致初始化用的 0 号线程也被多次唤醒，导致调度上的错误。

